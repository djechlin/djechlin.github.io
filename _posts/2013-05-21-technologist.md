---
title: Technologist skill-set
category: technology
layout: post
---

I do have a strong desire to be a very good technologist, or programmer, or software developer, or engineer.  The word changes a lot because they all keep sounding too narrow to me. Every time I really ask myself the question, "Am I passionate about coding?" the answer is no. I am passionate about solving problems, best practices, and theory in general, but this target moves far away and around code. 

I challenge you to think about what you are actually passionate about, that isn't coding. I've posted a list here but I imagine there is a common theme, and that theme ultimately will center around communication or the human experience that is software engineering: between software developers on a team, between developers participating in an ecosystem, between one developer and his or her future self, between developers and business.

* can you estimate how long it will take to do something and do something right based on nothing other than the fact that someone else has done something similar successfully? Do you care about project management?

* are you managing the flow of information into your own self: networking in person? Following good magazines or blogs? Active on something like StackOverflow and watching for new such online programmer hang-outs springing up?

* can you evaluate a technology's ecosystem? Does it have a good package manager, a good debugger, a well-adapted logging framework, a well-adapted testing framework, universal coding conventions instead of much hodge podge, and on, and on, and on.

* do you solve business problems and understand code as a tool? Do you like coding anyway?

* can you simultaneously operate at many levels of doing, thinking, and evaluating? This means supercharging your workflow by improving it every time you notice a glitch, but not being too prone to dropping what you're doing. How many times do you do something manually before you script? At the other end, do you make sure you're building the right thing, or notice when it's time to throw something out and build a larger module from scratch?

* do you factor out stuff that other people really shouldn't have to be doing too, into something sharable and reusable? Yes, I like open. A company benefits from a stronger ecosystem, and a fairly small percentage of what it does is only beneficial to its own industry or sector.

  And conversely, do you like the fact that what you are coding today you will merely be assembling tomorrow? We don't have to manage memory manually anymore, Node.js shows some promise in letting us forget about concurrent programming. There is an ecosystem of services like Amazon Web Services, logging endpoints and managers, etc. that let the programmer be something of a sysadmin. It's also becoming feasible for programmers to be their own DBAs without a specialist, in part, because middleware companies and new technologies like MongoDB are getting stronger at this.

* Do you have a DIY mentality? Throwing together a website should be something you're cool with doing, if you're at an part of the web development stack.

* can you knowledge-share with a team? When you figure out a new workflow in git do your teammates as well? More generally do you think of team scalability?

  * do you care about security, and understand that security ultimately is a pretty faithful function of knowing your domain? You don't have to understand any of proofs behind the math of cryptography, but you do need some intellectual curiosity toward what mathematical statements and high-level theorems make secure hashing and asymmetric encryption possible. Do you understand security as mechanical advantage and know where it comes from? Do you understand that security is shared between all programmers as well as end-users, and every party is responsible for increasing the vigilance of every other or at least every downstream party?

  Side note: I've realized the following words are very general philosophies. They are abstract in the sense that when they are used, their meaning must be inferred, "at runtime." Such words include: scalability, secure, open, dynamic [language].